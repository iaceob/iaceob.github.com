<!doctype html> <html> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1"> <link rel="icon" href="/favicon.svg"> <title>生物烯丙菊 - 达文西手电筒 - 第 9 頁</title> <link rel="stylesheet" href="/css/style.css"> </head> <body> <header class="head"> <h1 class="head-title"><a href="/">生物烯丙菊</a></h1> <h3 class="head-description"> <span class="flashlight">达文西手电筒</span> </h3> <ul class="head-nav"> <li><a href="/">Home</a></li> <li><a href="/archives">Archives</a></li> <li><a href="http://blog.3u3.me">幾文山</a></li> </ul> </header> <main class="main"> <article class="post"> <header class="post-head"> <time datetime="2013-11-13T15:11:05.000Z">November 13, 2013</time> <h1><a href="/post/eclipse-dev-java-web-project-automatically-restart-the-tomat-server/">eclipse 开发 java web 自动重启 tomcat 服务器</a></h1> </header> <section class="post-main"><p>eclipse 开发 java web 项目的时候, 每次一保存 java 文件 就会自动重启 tomcat 服务器</p> <p> </p> <p>解决方法:</p> <p>修改对应tomcat目录config下的server.xml文件</p> <blockquote> <p>reloadable="false"</p> </blockquote> <p>&lt;Context docBase="projectName" path="/projectName" reloadable="false" source="org.eclipse.jst.jee.server:projectName"/&gt;&lt;/Host&gt;</p> <p> </p></section> <footer class="post-foot"> <ul class="post-tags"> <li><a href="/tag/eclipse">eclipse</a></li> <li><a href="/tag/j2ee">j2ee</a></li> <li><a href="/tag/server-xml">server.xml</a></li> <li><a href="/tag/tomcat">tomcat</a></li> </ul> </footer> </article> <article class="post"> <header class="post-head"> <time datetime="2013-11-12T15:48:26.000Z">November 12, 2013</time> <h1><a href="/post/sql-sentence-mysql/">sql语句 – mysql</a></h1> </header> <section class="post-main"><p> </p> <p>创建一库</p> <pre>create database dbname;</pre> <p>显示所有库</p> <pre>show databases;</pre> <p>选择一个库</p> <pre>use dbname;</pre> <p>导出一个库</p> <pre>// 
mysqldump -uroot -p -t dbname&gt;'~/savepath/customdbname.sql'</pre> <p>查出当前库有多少外键</p> <pre>select    
    concat(table_name, '.', column_name) as 'foreign key',     
    concat(referenced_table_name, '.', referenced_column_name) as 'references'  
from  
    information_schema.key_column_usage   
where  
    table_schema='$databasename' and  
    referenced_table_name is not null;</pre> <p>删除外键</p> <pre>alter table table_name drop foreign key foreignKeyName;</pre> <p>删除/增加/修改 某表字段</p> <pre>alter table table_name drop column column_name; -- 删除
alter talbe table_name add column_name tinyint not null default 0; -- 增加
alter table table_name change column_name new_column_name integer; -- 重命名 column_name
</pre></section> <footer class="post-foot"> <ul class="post-tags"> <li><a href="/tag/mysql">mysql</a></li> <li><a href="/tag/sentence">sentence</a></li> <li><a href="/tag/sql">sql</a></li> </ul> </footer> </article> <article class="post"> <header class="post-head"> <time datetime="2013-11-08T15:37:24.000Z">November 8, 2013</time> <h1><a href="/post/not-free-to-use-lazy-loading/">不要随意使用懒加载！！</a></h1> </header> <section class="post-main"><p>记得之前看过说 hibernate 的懒加载使用 是在需要的地方就使用不需要的地方就不要使用。。。。</p> <p>很蛋疼的一句话 谁都知道啊 。。。。</p> <p>---</p> <p>虽然很蛋疼 不过还真就体会了一次 懒加载严重影响了系统的运行 代码如下</p> <p>分别有A实体类和B实体类 并且是多对多关系</p> <p>最终生成的表有3张 a b c 其中c表存储的是a表的id和b表的id</p> <pre>        Set&lt;A&gt; as = new HashSet&lt;A&gt;();
        A a = new A();
        String[] split = module.split(",");
        int aId;
        for (int i=0; i&lt;split.length; i++) {
            try {
                aId = Integer.parseInt(split[i]);
            } catch (Exception e) {
                e.printStackTrace();
                return "类型错误";
            }
            a = this.moduleDao.getAById(aId);
            modules.add(a);
        }
        B b = new B();
        b.setBID(bID);
        b.setBName(bName);
        b.setAs(as);
        b.setCreateUserID(uid);
        b.setCreateTime(new Date());
        String saveBID = this.bDao.saveB(b);</pre> <p>保存的代码就如上面 感觉很但疼 hibernate 这操作 。。。。。 还需要循环去查询数据库。。。</p> <p>然后就去跑了一遍，惊呆了，花了40多秒才执行完。。。。</p> <p>很是不解 非常不解 。。。</p> <p>试了好多次 下面这些是记录下来的 耗时 (根据测试数据不同隔开)</p> <pre>用时36539毫秒；36.539秒
用时27813毫秒；27.813秒
用时26473毫秒；26.473秒
用时30016毫秒；30.016秒
------------
用时29684毫秒；29.684秒
用时44141毫秒；44.141秒
用时28434毫秒；28.434秒
用时31013毫秒；31.013秒
------------
用时26366毫秒；26.366秒
用时28442毫秒；28.442秒
用时36296毫秒；36.296秒
用时31299毫秒；31.299秒
------------
用时42439毫秒；42.439秒
用时44764毫秒；44.764秒
------------
用时6260毫秒；6.26秒
用时3809毫秒；3.809秒
用时4187毫秒；4.187秒
用时3640毫秒；3.64秒
---------
用时23520毫秒；23.52秒
---------
用时65622毫秒；65.622秒

</pre> <p>只有几条数据的时候 就比较快 数据一多 耗时都是30-40左右。。。</p> <p>这特么还是本地测试。。。。</p> <p>之后看了下 hibernate 生成的 sql 发现查询b的时候把a也给查了而且只要是有数据的全部都给查了 这特么怎么能不慢 。。。。</p> <p>检查后发现b实体类中关联a类采用了懒加载</p> <p>把懒加载去掉后 再次去执行</p> <p>有了质的提高 不过 数据多了 还是有点慢 但是 比懒加载快很多！！！！</p></section> <footer class="post-foot"> <ul class="post-tags"> <li><a href="/tag/hibernate">hibernate</a></li> <li><a href="/tag/java">java</a></li> <li><a href="/tag/lazy">lazy</a></li> <li><a href="/tag/load">load</a></li> </ul> </footer> </article> <article class="post"> <header class="post-head"> <time datetime="2013-11-04T13:53:17.000Z">November 4, 2013</time> <h1><a href="/post/hibernate-errror-a-different-object-with-the-same-identifier-value-was-already-associated-with-the-session/">a different object with the same identifier value was already associated with the session</a></h1> </header> <section class="post-main"><p>hibernatre 出现如下错误： a different object with the same identifier value was already associated with the session</p> <p>--</p> <p>找了很多资料都说这是一个hibernate经典的错误。</p> <p>错误的原因是因为hibernate在执行操作数据库的时候在session 中发现了同一个实体类有着多个不同的下表 那么hibernate就不知道该去找那个来进行提交了。</p> <p>下面是我代码运行的错误报告</p> <pre>DEBUG - Collection found: [name.iaceob.entity.Aent.bents#61], Was:[name.iaceob.Aent.bents#61](initialized)
DEBUG - Collection found: [name.iaceob.entity.Bent.aents#1], Was:[name.iaceob.Bent.aents#6](initialized)
DEBUG - Collection found: [name.iaceob.entity.Bent.aents#1], Was:[name.iaceob.Bent.aents#6](initialized)
DEBUG - Flushed: 0 insertions, 0 updates, 0 deletions to 3 objects</pre> <p>在执行操作的时候 出现了3个object 其他的文章中也说过出现这种错误大多是在 一对多 或者 多对多 的关系中</p> <p>因为在这中关系中 hibernate 在操作数据库的时候会将这些数据都查出来赋值给对象 最终操作数据库的时候 session 中将会出现很多个这个对象 那么就会报出这样的错误。</p> <p>关于这个错误 解释的文章也很多 也提出了很多的解决办法</p> <blockquote> <p>使用session.clean()，如果在clean操作后面又进行了saveOrUpdate(object)等改变数据状态的操作，有可能会报出"Found two representations of same collection"异常。</p> <p>使用session.refresh(object)，当object不是数据库中已有数据的对象的时候，不能使用session.refresh(object)因为该方法是从hibernate的session中去重新取object，如果session中没有这个对象，则会报错所以当你使用saveOrUpdate(object)之前还需要判断一下。</p> <p>session.merge(object)，Hibernate里面自带的方法，推荐使用。</p> </blockquote> <p>不错 貌似是得这么解决，不过都没有什么实例。</p> <p>因为我项目中用的数据操作是 HibernateTemplate 所以这里提出的解决方法是针对这种进行的 如果不是使用的 HibernateTemplate 而是直接使用的 hibernate session 进行操作的 那么应该更加方便，直接如上面引入的方法进行操作即可</p> <pre>    public void updateLevel(final Aent aent) {
        // TODO Auto-generated method stub
        // this.hibernateTemplate.update(aent);
        this.hibernateTemplate.executeFind(new HibernateCallback() {

            public Object doInHibernate(Session session) throws HibernateException, SQLException {
                // TODO Auto-generated method stub
                Aent aent2 =  (Aent) session.merge(aent);
                session.update(aent2);
                return null;
            }

        });
    }</pre> <p>上面注释的 this.hibernateTemplate.update(aent); 便是直接操作数据的方式</p> <p>因为session中会出现很多的同样的对象 报错了使用的解决方式就是上面引入内容中的 session.merge() 这个方法，merge这个方法的主要作用就是合并对象的意思 把多个对象合并成为一个对象。</p> <p>合并 aent 后赋给一个新的对象，在进行修改或者添加，这样session 中只有一个对象了 就不会出现这个错误</p> <p>如果不是使用HibernateTemplate的话 我想应该比这解决要简单的多 直接 session.merge(entity) 就解决了</p> <p>HibernateTemplate 的 executeFind 这个方法里面的返回方法 要使用传递过来的参数 必须是 final 的才可以使用 final 的变量是不可以修改的，因此在返回方法中需要重新实例化一个对象 这个对象保存的就是合并后的对象 在进行操作数据。</p> <p> </p> <p>貌似 HibernateTemplate 也有 merge clean 等方法 但是在这里也试过了 也同样会报错。不能解决问题。</p> <p> </p> <p>======</p> <p>等等 HibernateTemplate 解决办法有了 而且还更加简单方便 。。</p> <pre>public void saveNews(News news){
      this.hibernateTemplate.merge(news);
}</pre> <p>这样就能直接提交到数据库了 不用在save了</p> <p>这样写过</p> <pre>public void saveNews(News news) {
     News nwes2 = this.hibernateTemplate.merge(news);
     this.hibernateTemplate.save(news2);
}</pre> <p>报错了 但是数据添加了 报错信息是因为 主键重复</p> <p>这里直接 merge 就提交到数据库了 返回的 merge 返回的是 提交的对象</p> <pre>News nwes2 = this.hibernateTemplate.merge(news);
news2.getNewsId(); // 获得提交到数据库的id</pre> <p> </p> <p>这个可以有 前面的解决方式 就无视了吧 虽然也能解决。</p></section> <footer class="post-foot"> <ul class="post-tags"> <li><a href="/tag/executefind">executeFind</a></li> <li><a href="/tag/hibernate">hibernate</a></li> <li><a href="/tag/hibernatetemplate">hibernatetemplate</a></li> <li><a href="/tag/java">java</a></li> <li><a href="/tag/merge">merge</a></li> <li><a href="/tag/update">update</a></li> </ul> </footer> </article> <article class="post"> <header class="post-head"> <time datetime="2013-10-30T02:41:07.000Z">October 30, 2013</time> <h1><a href="/post/j2ee-gzip-compress/">j2ee gzip 压缩</a></h1> </header> <section class="post-main"><p>又是压缩！！！</p> <p> </p> <p>又是在别出找的。。。。</p> <p> </p> <p>不过 效率还是很好的</p> <p> </p> <p>已经忘了 是在哪找到的了 同样和 之前的html压缩一样 因为出了问题 (和那是一样的问题)这里只把代码贴出来</p> <p> </p> <p>CompressionFilter.java</p> <pre>package name.iaceob.filter;

import java.io.IOException;
import java.util.Enumeration;
import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import name.iaceob.util.CompressionServletResponseWrapper;

/**
 * Implementation of &lt;code&gt;javax.servlet.Filter&lt;/code&gt; used to compress
 * the ServletResponse if it is bigger than a threshold.
 *
 * @author Amy Roh
 * @author Dmitri Valdin
 * @version $Revision: 267129 $, $Date: 2004-03-18 10:40:35 -0600 (Thu, 18 Mar 2004) $
 */

public class CompressionFilter implements Filter{

    /**
     * The filter configuration object we are associated with.  If this value
     * is null, this filter instance is not currently configured.
     */
    private FilterConfig config = null;

    /**
     * Minimal reasonable threshold
     */
    private int minThreshold = 128;

    /**
     * The threshold number to compress
     */
    protected int compressionThreshold;

    /**
     * Debug level for this filter
     */
    private int debug = 0;

    /**
     * Place this filter into service.
     *
     * @param filterConfig The filter configuration object
     */

    public void init(FilterConfig filterConfig) {

        config = filterConfig;
        if (filterConfig != null) {
            String value = filterConfig.getInitParameter("debug");
            if (value!=null) {
                debug = Integer.parseInt(value);
            } else {
                debug = 0;
            }
            String str = filterConfig.getInitParameter("compressionThreshold");
            if (str!=null) {
                compressionThreshold = Integer.parseInt(str);
                if (compressionThreshold != 0 &amp;&amp; compressionThreshold &lt; minThreshold) {
                    if (debug &gt; 0) {
                        System.out.println("compressionThreshold should be either 0 - no compression or &gt;= " + minThreshold);
                        System.out.println("compressionThreshold set to " + minThreshold);
                    }
                    compressionThreshold = minThreshold;
                }
            } else {
                compressionThreshold = 0;
            }

        } else {
            compressionThreshold = 0;
        }

    }

    /**
    * Take this filter out of service.
    */
    public void destroy() {

        this.config = null;

    }

    /**
     * The &lt;code&gt;doFilter&lt;/code&gt; method of the Filter is called by the container
     * each time a request/response pair is passed through the chain due
     * to a client request for a resource at the end of the chain.
     * The FilterChain passed into this method allows the Filter to pass on the
     * request and response to the next entity in the chain.&lt;p&gt;
     * This method first examines the request to check whether the client support
     * compression. &lt;br&gt;
     * It simply just pass the request and response if there is no support for
     * compression.&lt;br&gt;
     * If the compression support is available, it creates a
     * CompressionServletResponseWrapper object which compresses the content and
     * modifies the header if the content length is big enough.
     * It then invokes the next entity in the chain using the FilterChain object
     * (&lt;code&gt;chain.doFilter()&lt;/code&gt;), &lt;br&gt;
     **/

    public void doFilter ( ServletRequest request, ServletResponse response,
                        FilterChain chain ) throws IOException, ServletException {

        if (debug &gt; 0) {
            System.out.println("================");
            System.out.println("@doFilter");
        }

        if (compressionThreshold == 0) {
            if (debug &gt; 0) {
                System.out.println("doFilter gets called, but compressionTreshold is set to 0 - no compression");
            }
           System.out.println("没有压缩");
            chain.doFilter(request, response);
            return;
        }

        boolean supportCompression = false;
        if (request instanceof HttpServletRequest) {
            if (debug &gt; 1) {

                System.out.println("requestURI = " + ((HttpServletRequest)request).getRequestURI());
            }

            // Are we allowed to compress ?
            String s = (String) ((HttpServletRequest)request).getParameter("gzip");

            if ("false".equals(s)) {
                if (debug &gt; 0) {
                    System.out.println("got parameter gzip=false --&gt; don't compress, just chain filter");
                }

                chain.doFilter(request, response);
                return;
            }

            Enumeration e =
                ((HttpServletRequest)request).getHeaders("Accept-Encoding");
            while (e.hasMoreElements()) {
                String name = (String)e.nextElement();
                System.out.println(name);
                if (name.indexOf("gzip") != -1) {
                    if (debug &gt; 0) {
                        System.out.println("supports compression");
                    }
                    supportCompression = true;
                } else {
                    if (debug &gt; 0) {
                        System.out.println("no support for compresion");
                    }
                }
            }
        }

        if (!supportCompression) {
            if (debug &gt; 0) {
                System.out.println("doFilter gets called wo compression");
            }
            chain.doFilter(request, response);
            return;
        } else {
            if (response instanceof HttpServletResponse) {
                CompressionServletResponseWrapper wrappedResponse =
                    new CompressionServletResponseWrapper((HttpServletResponse)response);
                wrappedResponse.setDebugLevel(debug);

                wrappedResponse.setCompressionThreshold(compressionThreshold);
                if (debug &gt; 0) {
                    System.out.println("doFilter gets called with compression");
                }
                try {

                    chain.doFilter(request, wrappedResponse);
                } finally {
                    wrappedResponse.finishResponse();
                }
                return;
            }
        }
    }

    /**
     * Set filter config
     * This function is equivalent to init. Required by Weblogic 6.1
     *
     * @param filterConfig The filter configuration object
     */
    public void setFilterConfig(FilterConfig filterConfig) {
        init(filterConfig);
    }

    /**
     * Return filter config
     * Required by Weblogic 6.1
     */
    public FilterConfig getFilterConfig() {
        return config;
    }

}</pre> <p> </p> <p>CompressionServletResponseWrapper.java</p> <pre>package name.iaceob.util;

import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.util.Locale;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.ServletException;
import javax.servlet.ServletOutputStream;
import javax.servlet.ServletResponse;
import javax.servlet.ServletResponseWrapper;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpServletResponseWrapper;

/**
 * Implementation of &lt;b&gt;HttpServletResponseWrapper&lt;/b&gt; that works with
 * the CompressionServletResponseStream implementation..
 *
 * @author Amy Roh
 * @author Dmitri Valdin
 * @version $Revision: 267129 $, $Date: 2004-03-18 10:40:35 -0600 (Thu, 18 Mar 2004) $
 */

public class CompressionServletResponseWrapper extends HttpServletResponseWrapper {

    // ----------------------------------------------------- Constructor

    /**
     * Calls the parent constructor which creates a ServletResponse adaptor
     * wrapping the given response object.
     */

    public CompressionServletResponseWrapper(HttpServletResponse response) {
        super(response);
        origResponse = response;
        if (debug &gt; 1) {
            System.out.println("CompressionServletResponseWrapper constructor gets called");
        }
    }

    // ----------------------------------------------------- Instance Variables

    /**
     * Original response
     */

    protected HttpServletResponse origResponse = null;

    /**
     * Descriptive information about this Response implementation.
     */

    protected static final String info = "CompressionServletResponseWrapper";

    /**
     * The ServletOutputStream that has been returned by
     * &lt;code&gt;getOutputStream()&lt;/code&gt;, if any.
     */

    protected ServletOutputStream stream = null;

    /**
     * The PrintWriter that has been returned by
     * &lt;code&gt;getWriter()&lt;/code&gt;, if any.
     */

    protected PrintWriter writer = null;

    /**
     * The threshold number to compress
     */
    protected int threshold = 0;

    /**
     * Debug level
     */
    private int debug = 0;

    /**
     * Content type
     */
    protected String contentType = null;

    // --------------------------------------------------------- Public Methods

    /**
     * Set content type
     */
    public void setContentType(String contentType) {
        if (debug &gt; 1) {
            System.out.println("setContentType to "+contentType);
        }
        this.contentType = contentType;
        origResponse.setContentType(contentType);
    }

    /**
     * Set threshold number
     */
    public void setCompressionThreshold(int threshold) {
        if (debug &gt; 1) {
            System.out.println("setCompressionThreshold to " + threshold);
        }
        this.threshold = threshold;
    }

    /**
     * Set debug level
     */
    public void setDebugLevel(int debug) {
        this.debug = debug;
    }

    /**
     * Create and return a ServletOutputStream to write the content
     * associated with this Response.
     *
     * @exception IOException if an input/output error occurs
     */
    public ServletOutputStream createOutputStream() throws IOException {
        if (debug &gt; 1) {
            System.out.println("createOutputStream gets called");
        }

        CompressionResponseStream stream = new CompressionResponseStream(origResponse);
        stream.setDebugLevel(debug);
        stream.setBuffer(threshold);

        return stream;

    }

    /**
     * Finish a response.
     */
    public void finishResponse() {
        try {
            if (writer != null) {
                writer.close();
            } else {
                if (stream != null)
                    stream.close();
            }
        } catch (IOException e) {
        }
    }

    // ------------------------------------------------ ServletResponse Methods

    /**
     * Flush the buffer and commit this response.
     *
     * @exception IOException if an input/output error occurs
     */
    public void flushBuffer() throws IOException {
        if (debug &gt; 1) {
            System.out.println("flush buffer @ CompressionServletResponseWrapper");
        }
        ((CompressionResponseStream)stream).flush();

    }

    /**
     * Return the servlet output stream associated with this Response.
     *
     * @exception IllegalStateException if &lt;code&gt;getWriter&lt;/code&gt; has
     *  already been called for this response
     * @exception IOException if an input/output error occurs
     */
    public ServletOutputStream getOutputStream() throws IOException {

        if (writer != null)
            throw new IllegalStateException("getWriter() has already been called for this response");

        if (stream == null)
            stream = createOutputStream();
        if (debug &gt; 1) {
            System.out.println("stream is set to "+stream+" in getOutputStream");
        }

        return (stream);

    }

    /**
     * Return the writer associated with this Response.
     *
     * @exception IllegalStateException if &lt;code&gt;getOutputStream&lt;/code&gt; has
     *  already been called for this response
     * @exception IOException if an input/output error occurs
     */
    public PrintWriter getWriter() throws IOException {

        if (writer != null)
            return (writer);

        if (stream != null)
            throw new IllegalStateException("getOutputStream() has already been called for this response");

        stream = createOutputStream();
        if (debug &gt; 1) {
            System.out.println("stream is set to "+stream+" in getWriter");
        }
        //String charset = getCharsetFromContentType(contentType);
        String charEnc = origResponse.getCharacterEncoding();
        if (debug &gt; 1) {
            System.out.println("character encoding is " + charEnc);
        }
        // HttpServletResponse.getCharacterEncoding() shouldn't return null
        // according the spec, so feel free to remove that "if"
        if (charEnc != null) {
            writer = new PrintWriter(new OutputStreamWriter(stream, charEnc));
        } else {
            writer = new PrintWriter(stream);
        }

        return (writer);

    }

    public void setContentLength(int length) {
    }

    /**
     * Returns character from content type. This method was taken from tomcat.
     * @author rajo
     */
    private static String getCharsetFromContentType(String type) {

        if (type == null) {
            return null;
        }
        int semi = type.indexOf(";");
        if (semi == -1) {
            return null;
        }
        String afterSemi = type.substring(semi + 1);
        int charsetLocation = afterSemi.indexOf("charset=");
        if(charsetLocation == -1) {
            return null;
        } else {
            String afterCharset = afterSemi.substring(charsetLocation + 8);
            String encoding = afterCharset.trim();
            return encoding;
        }
    }

}</pre> <p>CompressionResponseStream.java</p> <pre>package name.iaceob.util; 

import java.io.IOException; 
import java.io.OutputStream; 
import java.util.zip.GZIPOutputStream; 
import javax.servlet.ServletOutputStream; 
import javax.servlet.http.HttpServletResponse; 

/** 
 * Implementation of &lt;b&gt;ServletOutputStream&lt;/b&gt; that works with 
 * the CompressionServletResponseWrapper implementation. 
 * 
 * @author Amy Roh 
 * @author Dmitri Valdin 
 * @version $Revision: 267129 $, $Date: 2004-03-18 10:40:35 -0600 (Thu, 18 Mar 2004) $ 
 */ 

public class CompressionResponseStream 
    extends ServletOutputStream { 

    // ----------------------------------------------------------- Constructors 

    /** 
     * Construct a servlet output stream associated with the specified Response. 
     * 
     * @param response The associated response 
     */ 
    public CompressionResponseStream(HttpServletResponse response) throws IOException{ 

        super(); 
        closed = false; 
        this.response = response; 
        this.output = response.getOutputStream(); 

    } 

    // ----------------------------------------------------- Instance Variables 

    /** 
     * The threshold number which decides to compress or not. 
     * Users can configure in web.xml to set it to fit their needs. 
     */ 
    protected int compressionThreshold = 0; 

    /** 
     * Debug level 
     */ 
    private int debug = 0; 

    /** 
     * The buffer through which all of our output bytes are passed. 
     */ 
    protected byte[] buffer = null; 

    /** 
     * The number of data bytes currently in the buffer. 
     */ 
    protected int bufferCount = 0; 

    /** 
     * The underlying gzip output stream to which we should write data. 
     */ 
    protected GZIPOutputStream gzipstream = null; 

    /** 
     * Has this stream been closed? 
     */ 
    protected boolean closed = false; 

    /** 
     * The content length past which we will not write, or -1 if there is 
     * no defined content length. 
     */ 
    protected int length = -1; 

    /** 
     * The response with which this servlet output stream is associated. 
     */ 
    protected HttpServletResponse response = null; 

    /** 
     * The underlying servket output stream to which we should write data. 
     */ 
    protected ServletOutputStream output = null; 

    // --------------------------------------------------------- Public Methods 

    /** 
     * Set debug level 
     */ 
    public void setDebugLevel(int debug) { 
        this.debug = debug; 
    } 

    /** 
     * Set the compressionThreshold number and create buffer for this size 
     */ 
    protected void setBuffer(int threshold) { 
        compressionThreshold = threshold; 
        buffer = new byte[compressionThreshold]; 
        if (debug &gt; 1) { 
            System.out.println("buffer is set to "+compressionThreshold); 
        } 
    } 

    /** 
     * Close this output stream, causing any buffered data to be flushed and 
     * any further output data to throw an IOException. 
     */ 
    public void close() throws IOException { 

        if (debug &gt; 1) { 
            System.out.println("close() @ CompressionResponseStream"); 
        } 
        if (closed) 
            throw new IOException("This output stream has already been closed"); 

        if (gzipstream != null) { 
            flushToGZip(); 
            gzipstream.close(); 
            gzipstream = null; 
        } else { 
            if (bufferCount &gt; 0) { 
                if (debug &gt; 2) { 
                    System.out.print("output.write("); 
                    System.out.write(buffer, 0, bufferCount); 
                    System.out.println(")"); 
                } 
                output.write(buffer, 0, bufferCount); 
                bufferCount = 0; 
            } 
        } 

        output.close(); 
        closed = true; 

    } 

    /** 
     * Flush any buffered data for this output stream, which also causes the 
     * response to be committed. 
     */ 
    public void flush() throws IOException { 

        if (debug &gt; 1) { 
            System.out.println("flush() @ CompressionResponseStream"); 
        } 
        if (closed) { 
            throw new IOException("Cannot flush a closed output stream"); 
        } 

        if (gzipstream != null) { 
            gzipstream.flush(); 
        } 

    } 

    public void flushToGZip() throws IOException { 

        if (debug &gt; 1) { 
            System.out.println("flushToGZip() @ CompressionResponseStream"); 
        } 
        if (bufferCount &gt; 0) { 
            if (debug &gt; 1) { 
                System.out.println("flushing out to GZipStream, bufferCount = " + bufferCount); 
            } 
            writeToGZip(buffer, 0, bufferCount); 
            bufferCount = 0; 
        } 

    } 

    /** 
     * Write the specified byte to our output stream. 
     * 
     * @param b The byte to be written 
     * 
     * @exception IOException if an input/output error occurs 
     */ 
    public void write(int b) throws IOException { 

        if (debug &gt; 1) { 
            System.out.println("write "+b+" in CompressionResponseStream "); 
        } 
        if (closed) 
            throw new IOException("Cannot write to a closed output stream"); 

        if (bufferCount &gt;= buffer.length) { 
            flushToGZip(); 
        } 

        buffer[bufferCount++] = (byte) b; 

    } 

    /** 
     * Write &lt;code&gt;b.length&lt;/code&gt; bytes from the specified byte array 
     * to our output stream. 
     * 
     * @param b The byte array to be written 
     * 
     * @exception IOException if an input/output error occurs 
     */ 
    public void write(byte b[]) throws IOException { 

        write(b, 0, b.length); 

    } 

    /** 
     * Write &lt;code&gt;len&lt;/code&gt; bytes from the specified byte array, starting 
     * at the specified offset, to our output stream. 
     * 
     * @param b The byte array containing the bytes to be written 
     * @param off Zero-relative starting offset of the bytes to be written 
     * @param len The number of bytes to be written 
     * 
     * @exception IOException if an input/output error occurs 
     */ 
    public void write(byte b[], int off, int len) throws IOException { 

        if (debug &gt; 1) { 
            System.out.println("write, bufferCount = " + bufferCount + " len = " + len + " off = " + off); 
        } 
        if (debug &gt; 2) { 
            System.out.print("write("); 
            System.out.write(b, off, len); 
            System.out.println(")"); 
        } 

        if (closed) 
            throw new IOException("Cannot write to a closed output stream"); 

        if (len == 0) 
            return; 

        // Can we write into buffer ? 
        if (len &lt;= (buffer.length - bufferCount)) { 
            System.arraycopy(b, off, buffer, bufferCount, len); 
            bufferCount += len; 
            return; 
        } 

        // There is not enough space in buffer. Flush it ... 
        flushToGZip(); 

        // ... and try again. Note, that bufferCount = 0 here ! 
        if (len &lt;= (buffer.length - bufferCount)) { 
            System.arraycopy(b, off, buffer, bufferCount, len); 
            bufferCount += len; 
            return; 
        } 

        // write direct to gzip 
        writeToGZip(b, off, len); 
    } 

    public void writeToGZip(byte b[], int off, int len) throws IOException { 

        if (debug &gt; 1) { 
            System.out.println("writeToGZip, len = " + len); 
        } 
        if (debug &gt; 2) { 
            System.out.print("writeToGZip("); 
            System.out.write(b, off, len); 
            System.out.println(")"); 
        } 
        if (gzipstream == null) { 
            if (debug &gt; 1) { 
                System.out.println("new GZIPOutputStream"); 
            } 
            response.addHeader("Content-Encoding", "gzip"); 
            gzipstream = new GZIPOutputStream(output); 
        } 
        gzipstream.write(b, off, len); 

    } 

    // -------------------------------------------------------- Package Methods 

    /** 
     * Has this response stream been closed? 
     */ 
    public boolean closed() { 

        return (this.closed); 

    } 

}</pre> <p> </p> <p>web.xml</p> <pre>     &lt;!-- Gzip 页面压缩  Bug--&gt;
     &lt;filter&gt;
         &lt;filter-name&gt;gzipCompression&lt;/filter-name&gt;
         &lt;filter-class&gt;name.iaceob.filter.CompressionFilter&lt;/filter-class&gt;
        &lt;init-param&gt;
          &lt;param-name&gt;compressionThreshold&lt;/param-name&gt;
          &lt;param-value&gt;512&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;init-param&gt;
          &lt;param-name&gt;debug&lt;/param-name&gt;
          &lt;param-value&gt;0&lt;/param-value&gt;
        &lt;/init-param&gt;
     &lt;/filter&gt;
     &lt;filter-mapping&gt;
         &lt;filter-name&gt;gzipCompression&lt;/filter-name&gt;
         &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
     &lt;/filter-mapping&gt;</pre> <p> </p> <p> </p> <p> </p> <p>-----</p> <p>结束 。。。。。</p> <p>最明显的显示 就是 在火狐浏览器 中 右键查看网页信息</p> <p>让之前 20 多k的一个页面 压缩成了 2-3k左右 效果很惊人！！！</p> <p>改天在找找这些资料 这里的代码应该是可以跑起来的</p> <p>错误也是配置的位置问题 要放在一些过滤器 或者其他框架的前面 否则 项目启动可能就会报错。。</p> <p> </p> <p> </p></section> <footer class="post-foot"> <ul class="post-tags"> <li><a href="/tag/compressor">compressor</a></li> <li><a href="/tag/filter">filter</a></li> <li><a href="/tag/gzip">gzip</a></li> <li><a href="/tag/j2ee">j2ee</a></li> <li><a href="/tag/java">java</a></li> </ul> </footer> </article> <article class="post"> <header class="post-head"> <time datetime="2013-10-30T02:28:55.000Z">October 30, 2013</time> <h1><a href="/post/j2ee-html-compressor-filter/">j2ee html 压缩过滤器</a></h1> </header> <section class="post-main"><p>说起html压缩相信也很多人都知道</p> <p>html压缩后能更快的被浏览器解释 等等一些好处</p> <p>之前写那个整合框架的时候就想要把html压缩这功能加上去 传到前台浏览器解析的html全部都是一行</p> <p>找了很久都没有任何进展 也大概能想到是怎么实现 可惜。。。慢慢学吧！</p> <p>不负有心人 最近让我给找到了</p> <p>是在下面这篇博文中看到的实现方式</p> <p>http://www.fanyanan.com/note/item/97-jsp-filter-compress-html</p> <p>(表示大神给跪)</p> <p>总体的按照该篇文章实现了html的压缩功能</p> <p>不过也是有问题的 下面说说遇到的问题 (关于怎么实现压缩代码势力那篇文章中也都写过了 这里只把代码贴出来 解释就算了 到那篇文章去看吧)</p> <p>先贴代码</p> <p>HtmlCompressorFilter.java</p> <pre>/*****************
*
* 执行压缩html
*/
public void doFilter(ServletRequest filterRequest, ServletResponse filterResponse, FilterChain filterChain) throws IOException, ServletException {
// TODO Auto-generated method stub

HttpServletRequest request = (HttpServletRequest)filterRequest;
HttpServletResponse response = (HttpServletResponse)filterResponse;
ServletContext servletContext = null ;

CharResponseWrapper charResponseWrapper = new CharResponseWrapper(response);
filterChain.doFilter(filterRequest, charResponseWrapper);
String html = charResponseWrapper.toString();

HtmlCompressor compressor = new HtmlCompressor();
//        compressor.setEnabled(true); // 如果为false，所有的压缩关闭(默认值是true)
//        compressor.setRemoveComments(true); // 如果为false保持HTML注释(默认值是true)
//        compressor.setRemoveMultiSpaces(true);  // 如果为false保持多个空白字符(默认值是true)
//        compressor.setRemoveIntertagSpaces(true); // 删除迭代标签空白字符
//        compressor.setRemoveQuotes(true);  // 删除不必要的标签属性报价
//        compressor.setCompressCss(true); // css 压缩
//        compressor.setCompressJavaScript(true); //  js压缩

try {
html=compressor.compress(html);
} catch (Exception e) {
e.printStackTrace();
}

response.getWriter().write(html);

}</pre> <p>HtmlCompressor.java</p> <p>这个类没有使用那篇文章中提到的jar包而是提取出来的java文件，下面给出链接</p> <p>web.xml</p> <pre>    &lt;!-- 统一样式    sitemesh  --&gt;
    &lt;filter&gt;
        &lt;filter-name&gt;sitemesh&lt;/filter-name&gt;
        &lt;filter-class&gt;com.opensymphony.module.sitemesh.filter.PageFilter&lt;/filter-class&gt;
        &lt;!--&lt;filter-class&gt;org.sitemesh.config.ConfigurableSiteMeshFilter&lt;/filter-class&gt;--&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;sitemesh&lt;/filter-name&gt;
        &lt;url-pattern&gt;*.htm&lt;/url-pattern&gt;
        &lt;url-pattern&gt;*.html&lt;/url-pattern&gt;
        &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;
        &lt;url-pattern&gt;*.action&lt;/url-pattern&gt;
        &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;

..........

     &lt;!-- html 压缩过滤器 --&gt;
     &lt;filter&gt;
         &lt;filter-name&gt;htmlCompressorFilter&lt;/filter-name&gt;
         &lt;filter-class&gt;name.iaceob.filter.HtmlCompressorFilter&lt;/filter-class&gt;
     &lt;/filter&gt;
     &lt;filter-mapping&gt;
         &lt;filter-name&gt;htmlCompressorFilter&lt;/filter-name&gt;
          &lt;url-pattern&gt;/*&lt;/url-pattern&gt; 
        &lt;!-- &lt;url-pattern&gt;*.css&lt;/url-pattern&gt;
         &lt;url-pattern&gt;*.htm&lt;/url-pattern&gt;
          &lt;url-pattern&gt;*.html&lt;/url-pattern&gt;
          &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;
         &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;
         &lt;url-pattern&gt;*.action&lt;/url-pattern&gt; --&gt;
     &lt;/filter-mapping&gt;</pre> <p>这里只单独列出了 sitemesh 的配置和 html 压缩的配置 因为就是 sitemesh 除了问题 那篇文章中也说到了</p> <p>----------</p> <p>跑起来</p> <p>html 是被压缩了但是压缩的只是部分 也就是 &lt;decorator:body/&gt; 被sitemesh引入的部分 而且url还必须是jsp或者html才能被压缩 struts 或者其他被过滤的链接 都不会被压缩。</p> <p>试了很多方法都不行 仍然是这样 包括 升级了sitemesh 后来想想也就作罢 又时间在看看</p> <p>今天 恰好又有了兴趣 来看看</p> <p>忽然间发现一个问题这个html压缩的过滤器是找到这个页面的uri然后对其进行压缩 在写出 因为sitemesh在前面操作过这个页面 那么到后面的这个html压缩的过滤器 这个时候 uri 不是这个页面的真正uri了 而是被sitemesh过滤后的uri(那篇文章中也有提到)，这么一想 如果让html压缩的过滤器先跑 在去跑sitemesh的过滤器，然后就试了以下，然后果然可以了！！！！！！！</p> <p>----</p> <p>解决方法就是 把html压缩过滤器放到sitemesh的前面就行了</p> <p>原流程 jsp-&gt;sitemesh-&gt;htmlcompressor</p> <p>现流程 jsp-&gt;htmlcompressor-&gt;sitemesh</p> <p>有俩个jsp文件 a.jsp b.jsp</p> <p>a.jsp 是 sitemesh 的模板文件 b.jsp 值 sitemesh 的body文件</p> <p>a.jsp</p> <pre>&lt;html&gt;
     &lt;head&gt;
        &lt;title&gt;&lt;decorator:title default="test"/&gt; - sitemesh&lt;/title&gt;
     &lt;/head&gt;
     &lt;body&gt;
       &lt;decorator:body/&gt;
     &lt;/body&gt;
&lt;/html&gt;</pre> <p>b.html</p> <pre>&lt;html&gt;

    &lt;head&gt;
        &lt;title&gt;html compressor&lt;/title&gt;
    &lt;/head&gt;

     &lt;body&gt;
           &lt;h1&gt;Hello World !&lt;/h1&gt;
           &lt;h2&gt;Welcome !&lt;/h2&gt; 
     &lt;/body&gt;
&lt;/html&gt;</pre> <p>之前流程</p> <p>sitemesh 先合并 页面</p> <pre>&lt;html&gt;
     &lt;head&gt;
        &lt;title&gt;test - sitemesh&lt;/title&gt;
     &lt;/head&gt;
     &lt;body&gt;
        &lt;h1&gt;Hello World !&lt;/h1&gt;
        &lt;h2&gt;Welcome !&lt;h2&gt;
     &lt;/body&gt;
&lt;/html&gt;</pre> <p>html 压缩过滤器 在进行压缩</p> <pre>&lt;html&gt;
     &lt;head&gt;
        &lt;title&gt;test - sitemesh&lt;/title&gt;
     &lt;/head&gt;
     &lt;body&gt;
        &lt;h1&gt;Hello World !&lt;/h1&gt;&lt;h2&gt;Welcome !&lt;h2&gt;
     &lt;/body&gt;
&lt;/html&gt;</pre> <p> </p> <p>只能压缩 b.jsp 中的内容 而且页面还必须是要访问 b.jsp 才可以</p> <p>第二种</p> <p>html 压缩过滤器 先压缩html</p> <p>a.jsp</p> <pre>&lt;html&gt;&lt;head&gt;&lt;title&gt;&lt;decorator:title default="test"/&gt; - sitemesh&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;decorator:body/&gt;&lt;/body&gt;&lt;/html&gt;</pre> <p>d.jsp</p> <pre>&lt;html&gt;&lt;head&gt;&lt;title&gt;html compressor&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Hello World !&lt;/h1&gt;&lt;h2&gt;Welcome !&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt;</pre> <p>之后 sitemesh 在合并</p> <pre>&lt;html&gt;&lt;head&gt;&lt;title&gt;html compressor - sitemesh&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Hello World !&lt;/h1&gt;&lt;h2&gt;Welcome !&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt;</pre> <p>这样 最终 所有的html代码都会被压缩</p> <p> </p> <p>-----</p> <p>修改后的web.xml 如下</p> <pre>     &lt;!-- html 压缩过滤器 --&gt;
     &lt;filter&gt;
         &lt;filter-name&gt;htmlCompressorFilter&lt;/filter-name&gt;
         &lt;filter-class&gt;com.kunda.filter.HtmlCompressorFilter&lt;/filter-class&gt;
     &lt;/filter&gt;
     &lt;filter-mapping&gt;
         &lt;filter-name&gt;htmlCompressorFilter&lt;/filter-name&gt;
         &lt;url-pattern&gt;/*&lt;/url-pattern&gt; 
     &lt;!--    &lt;url-pattern&gt;*.css&lt;/url-pattern&gt;
         &lt;url-pattern&gt;*.htm&lt;/url-pattern&gt;
          &lt;url-pattern&gt;*.html&lt;/url-pattern&gt;
          &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;
         &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;
         &lt;url-pattern&gt;*.action&lt;/url-pattern&gt; --&gt;
     &lt;/filter-mapping&gt;

......

    &lt;!-- 统一样式    sitemesh  --&gt;
    &lt;filter&gt;
        &lt;filter-name&gt;sitemesh&lt;/filter-name&gt;
        &lt;filter-class&gt;com.opensymphony.module.sitemesh.filter.PageFilter&lt;/filter-class&gt;
        &lt;!--&lt;filter-class&gt;org.sitemesh.config.ConfigurableSiteMeshFilter&lt;/filter-class&gt;--&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;sitemesh&lt;/filter-name&gt;
        &lt;url-pattern&gt;*.htm&lt;/url-pattern&gt;
        &lt;url-pattern&gt;*.html&lt;/url-pattern&gt;
        &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;
        &lt;url-pattern&gt;*.action&lt;/url-pattern&gt;
        &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;</pre> <p>这样 所有的页面都会被压缩</p> <p> </p> <p>不过又产生了一个问题 。。。。。</p> <p>因为项目中使用了 dwr 这个过滤器也顺便把dwr生成的js给压缩了 。。。</p> <p>导致 dwr 不能使用</p> <p>俩个解决办法</p> <p>一个是把dwr的配置拿到html压缩的配置上面</p> <p>一个是在 html压缩过滤其中 的url-pattern 设置压缩的后缀名 不要写js就不会被压缩</p> <pre>     &lt;!-- html 压缩过滤器 --&gt;
     &lt;filter&gt;
         &lt;filter-name&gt;htmlCompressorFilter&lt;/filter-name&gt;
         &lt;filter-class&gt;com.kunda.filter.HtmlCompressorFilter&lt;/filter-class&gt;
     &lt;/filter&gt;
     &lt;filter-mapping&gt;
         &lt;filter-name&gt;htmlCompressorFilter&lt;/filter-name&gt;
&lt;!--          &lt;url-pattern&gt;/*&lt;/url-pattern&gt; --&gt;
         &lt;url-pattern&gt;*.css&lt;/url-pattern&gt;
         &lt;url-pattern&gt;*.htm&lt;/url-pattern&gt;
          &lt;url-pattern&gt;*.html&lt;/url-pattern&gt;
          &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;
         &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;
         &lt;url-pattern&gt;*.action&lt;/url-pattern&gt;
     &lt;/filter-mapping&gt;</pre> <p>当然 我没看到自己写的js或者css被压缩 。。。。。。</p> <p> </p> <p>好了 html 压缩的配置就到这了 这样 也就会压缩html了 到前台的html代码就会被压缩成一行</p> <p>html被压缩的站点 最常见的是 google 了 google 的几乎所有页面都是被压缩过的</p> <p> </p> <p>这样 提高了效率 也减慢了效率</p> <p>提高的是浏览器解析的效率 减慢的是服务器的效率</p> <p>就像那篇文章中说的</p> <blockquote> <p> 和起初预想的一样，这个Filter出现了性能问题，使用大量的正则与替换文本影响到了性能。12kb的网页用了40ms才过滤完。</p> </blockquote> <p> </p> <p>服务器的压力会增大 有所的就有所失 。。。。。。</p> <p>只能想想 用其他的办法来优化这个问题了。</p> <p>试个人而选吧。</p> <p> </p> <p><a title="HtmlCompressor" href="http://pan.baidu.com/s/103jL6" target="_blank">HtmlCompressor.zip</a></p> <p>(这个也是在网上找到的 在哪忘了 目测 直接搜 htmlcompressor 就会搜到， 也是一片博文)</p> <p> </p> <p> </p> <p> </p></section> <footer class="post-foot"> <ul class="post-tags"> <li><a href="/tag/compressor">compressor</a></li> <li><a href="/tag/filter">filter</a></li> <li><a href="/tag/html">html</a></li> <li><a href="/tag/j2ee">j2ee</a></li> <li><a href="/tag/java">java</a></li> </ul> </footer> </article> <article class="post"> <header class="post-head"> <time datetime="2013-10-25T20:02:44.000Z">October 25, 2013</time> <h1><a href="/post/hql-variable-order-problem/">hql 中变量顺序问题</a></h1> </header> <section class="post-main"><p>hibernate 的查询并没有直接使用sql语句，而是封装成了hql</p> <p>hql在每次查询的时候需要各个字段的值只需要写入对应对象中的变量即可</p> <p>hql中使用的变量需要在改对象中有相应的构造方法才可以</p> <p>今天写了一个hql报错了，很诧异报错信息如下</p> <pre>cause=org.hibernate.PropertyNotFoundException: no appropriate constructor</pre> <p>告诉我没有相应的构造方法。。。当然是有的。。。</p> <p> </p> <pre>String hql = "select new Test(test.a, test.b,test.c, test.d) from Test as test";</pre> <p>Test.java</p> <pre>public Test(String a, int b, String d, String c) {
	this.a = a;
	this.b = b;
	this.d = d;
	this.c = c;
}</pre> <p>构造方法明明是有的 而且四个变量也都是相同的。。可还是报错。。</p> <p>因为之前也用过这个对象 还有其他的构造方法 试了其他的变量 尽然可以跑通 那就不是代码的问题了 而是 hql或者这个对象的问题了。</p> <p>试了几次 发现俩个都是没问题的。。。。。</p> <p>也拿去搜了搜 不过答案都是没有构造方法 。。可这明明是有的。。</p> <p> </p> <p>又看了看 发现 hql 中使用的变量的顺序和构造方法中的顺序不一样</p> <p>hql中</p> <p>test.a, test.b, test.c, test.d</p> <p>构造方法中</p> <p>String a, int b, String d, String c</p> <p>本着试试看的心态。。。把构造函数中的顺序改成和hql中一样，一跑 卧槽 通了。。。。。。。。。。。。</p> <p>这。。。。。</p> <p>原来不仅仅要有构造方法 构造方法中变量的顺序还必须要和hql中的一样，，否则hql就找不到这个方法。。。</p> <p>构造方法 我都是用自动生成的 没有手打 。。。。。。</p> <p>还特地试了其他的hql改变顺序 然后跑不通了 。。。(卧槽运气这么好 这么多次顺序都正确)</p> <p>好吧 当初没认真学 真不知道这是什么原因。。。</p> <p>看来得好好补补了。。。</p> <p> </p> <p> </p></section> <footer class="post-foot"> <ul class="post-tags"> <li><a href="/tag/constructors">constructors</a></li> <li><a href="/tag/hibernate">hibernate</a></li> <li><a href="/tag/hql">hql</a></li> <li><a href="/tag/java">java</a></li> </ul> </footer> </article> <article class="post"> <header class="post-head"> <time datetime="2013-10-25T16:48:45.000Z">October 25, 2013</time> <h1><a href="/post/sql-in-or-and-union-efficiency/">sql 中 or 和 union 效率</a></h1> </header> <section class="post-main"><p> </p> <p>select * from tablename where time=’2013-1-1′ or time=’2013-1-15′;</p> <p>select * from tablename where time=’2013-1-1′<br/> union<br/> select * from tablename where time=’2013-1-15′;</p> <p>or 查询会将表里面的所有数据都检索一次然后再去进行匹配</p> <p>union 查询 多个查询语句查多少数据只检索多少条</p> <p> </p> <p>去查了查 发现了俩中结果 乱了 。。。</p> <p>http://www.open-open.com/lib/view/open1346289165426.html</p> <p> </p> <blockquote> <p>笔者发现如果or两边的查询列是一样的话,那么用union则反倒和用or的执行速度差很多,虽然这里union扫描的是索引,而or扫描的是全表。</p> <p>select gid,fariqi,neibuyonghu,reader,title from Tgongwen where fariqi=‘2004-9-16‘ or fariqi=‘2004-2-5‘</p> <p>用时：6423毫秒。扫描计数 2,逻辑读 14726 次,物理读 1 次,预读 7176 次。</p> <p>select gid,fariqi,neibuyonghu,reader,title from Tgongwen where fariqi=‘2004-9-16‘</p> <p>union</p> <p>select gid,fariqi,neibuyonghu,reader,title from Tgongwen where fariqi=‘2004-2-5‘</p> <p>用时：11640毫秒。扫描计数 8,逻辑读 14806 次,物理读 108 次,预读 1144 次</p> </blockquote> <p>http://blog.csdn.net/duanjianmin/article/details/6631339</p> <p> </p> <blockquote> <p align="left"> 当SQL语句有多个or语句时，可以考虑使用union或者union all代替来提高速度。使用or的SQL语句往往无法进行优化，导致速度变慢。但这不是固定的，有时候使用or速度会更快些。具体情况还要经过测试为准。如果加索引的话，也可能实现速度优化。</p> <p align="left"> 实验表格如下,实际数据有2,000,000条，从里面返回大约最多1000行左右的数据。</p> <table id="table1" border="1"> <tbody> <tr> <td align="center" bgcolor="#c0c0c0">X</td> <td align="center" bgcolor="#c0c0c0">Y</td> <td align="center" bgcolor="#c0c0c0">Inline</td> <td align="center" bgcolor="#c0c0c0">CDP</td> <td align="center" bgcolor="#c0c0c0">T</td> </tr> <tr> <td>12002400</td> <td>5801000</td> <td>300</td> <td>300</td> <td>3400</td> </tr> <tr> <td>12002408</td> <td>5801005</td> <td>300</td> <td>301</td> <td>3402</td> </tr> <tr> <td>12002416</td> <td>5801010</td> <td>300</td> <td>302</td> <td>3404</td> </tr> <tr> <td>12002424</td> <td>5801015</td> <td>300</td> <td>303</td> <td>3406</td> </tr> <tr> <td>...</td> <td>...</td> <td>...</td> <td>...</td> <td>...</td> </tr> </tbody> </table> <p>or语句(部分节选)</p> <p align="left">SELECT * FROM tablename where (cdp= 300 and inline=301) or (cdp= 301 and inline=301) or (cdp= 302 and inline=301) or (cdp= 303 and inline=301) or (cdp= 304 and inline=301) or (cdp= 305 and inline=301) or (cdp= 306 and inline=301) or (cdp= 307 and inline=301)</p> <p align="left">union all语句(部分节选)</p> <p align="left">SELECT * FROM tablename where (inline= 300 and cdp=300) union all SELECT * FROM tablename where (inline= 301 and cdp=300) union all SELECT * FROM tablename where (inline= 302 and cdp=300) union all SELECT * FROM tablename where (inline= 303 and cdp=300)</p> <p align="left">返回不规则的900条数据，前者用了60多秒，后者用了8秒左右。</p> </blockquote> <p>到底是哪个我也不知到了，，，，</p> <p>这事还是得自己测 。。。。。</p> <p>现在也没有数据。。。。。</p> <p>过段时间有大批量的数据 就来测试测试 暂时先用or来查询</p> <p> </p> <p> </p> <p>========================== 14-08-08 修改</p> <p>这么长时间了 也使用了好多了 现在来看 in 和 or 的效率比较从大数据方面来说 in 应该会比 or 效率更高</p> <p>in的逻辑是 目标数据中使用有和 in 里面有像匹配的</p> <p>in 的查询在拿到目标数据后, 遍历判断是否有in里面相同的值</p> <p>而对用or来说, 有多少or就遍历几次目标数据,判断是否有相同的值</p> <p> </p> <p>============================14-09-27</p> <p>楼上的二货...</p> <p>标题明明写着 or union 的效率</p> <p>回什么 or 和 in</p> <p>..... 脑抽</p></section> <footer class="post-foot"> <ul class="post-tags"> <li><a href="/tag/mysql">mysql</a></li> <li><a href="/tag/or">or</a></li> <li><a href="/tag/sql">sql</a></li> <li><a href="/tag/union">union</a></li> </ul> </footer> </article> <article class="post"> <header class="post-head"> <time datetime="2013-10-23T01:57:44.000Z">October 23, 2013</time> <h1><a href="/post/ubuntu-opera-rar/">ubuntu 操作 rar</a></h1> </header> <section class="post-main"><p>压缩功能</p> <p>安装 sudo apt-get install rar<br/> 卸载 sudo apt-get remove rar</p> <p>解压功能</p> <p>安装 sudo apt-get install unrar<br/> 卸载 sudo apt-get remove unrar</p> <p> </p> <p>解压 rar</p> <p>unrar x -o- -y packagename.rar /home</p></section> <footer class="post-foot"> <ul class="post-tags"> <li><a href="/tag/rar">rar</a></li> <li><a href="/tag/ubuntu">ubuntu</a></li> <li><a href="/tag/unrar">unrar</a></li> </ul> </footer> </article> <article class="post"> <header class="post-head"> <time datetime="2013-10-23T01:30:44.000Z">October 23, 2013</time> <h1><a href="/post/hibernate-org-hibernate-hql-ast-tree-sqlnode-cannot-be-cast-to-org-hibernate-hql-ast-tree-fromreferencenode/">hibernate org.hibernate.hql.ast.tree.SqlNode cannot be cast to org.hibernate.hql.ast.tree.FromReferenceNode</a></h1> </header> <section class="post-main"><p>项目开发中遇到了bug，报错信息就如标题所显示</p> <pre>org.hibernate.hql.ast.tree.SqlNode cannot be cast to org.hibernate.hql.ast.tree.FromReferenceNode</pre> <p>log4j 在解析hql之前也有个报错信息</p> <pre>DEBUG - Keyword  'Order' is being interpreted as an identifier due to: expecting IDENT, found 'Order'</pre> <p>出现这个错误是因为hql中某个字符和数据库的关键字冲突造成的，项目中订单的实体类名是 Order 写的 hql 如下</p> <pre>select new Order(order.orderid, order.ordername) from Order as order;</pre> <p>搭建之初并没有考虑到关键字的问题甚至在遇到这个错误的时候还是没能发觉是什么地方出了问题，不禁一番感慨。。。。</p> <p>log4j都提示了错误 还是没看到 。。。</p> <p>order 是数据库的关键字 所以这里的订单实体类就不能用 Order 了。</p> <p>要修改的并不是 as 后面的order，那个order只是一个别名，hibernate将hql转化的时候会再次重命名所以不用担心这个会和关键字冲突，需要修改的是Order实体类名。</p> <p>修改了Order为Order_T</p> <p>最后hql为</p> <pre>select new Order_T(order.orderid, order.ordername) from Order_T as order;</pre> <p>问题解决了。</p> <p> </p> <p>-----</p> <p>要学的真的很多 多注意写细节。。。。</p></section> <footer class="post-foot"> <ul class="post-tags"> <li><a href="/tag/hql">hql</a></li> <li><a href="/tag/java">java</a></li> <li><a href="/tag/keyword">keyword</a></li> <li><a href="/tag/ubuntu">ubuntu</a></li> </ul> </footer> </article> <menu class="page"> <li class="page-prev"> <a href="/page/8" title="Previous">Prev</a> </li> <li class="page-next"> <a href="/page/10" title="Next">Next</a> </li> </menu> </main> <footer class="foot"> <div>&copy;2017 iaceob</div> </footer> </body> </html>