<!doctype html> <html> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1"> <link rel="icon" href="/favicon.svg"> <title>union - 生物烯丙菊</title> <link rel="stylesheet" href="/css/style.css"> </head> <body> <header class="head"> <h1 class="head-title"><a href="/">生物烯丙菊</a></h1> <h3 class="head-description"> <span class="flashlight">达文西手电筒</span> </h3> <ul class="head-nav"> <li><a href="/">Home</a></li> <li><a href="/archives">Archives</a></li> <li><a href="http://blog.3u3.me">幾文山</a></li> </ul> </header> <main class="main"> <article class="post"> <header class="post-head"> <time datetime="2014-11-08T00:26:37.000Z">November 8, 2014</time> <h1><a href="/post/sql-full-join-and-union/">sql 中 full join 于 union</a></h1> </header> <section class="post-main"><p>在 sql 的众多的 join 中存在一个 full join</p> <p>full join 的作用是全关联, 也就是不管俩边的表数据书否被关联上, 都会被一起输出, 未被关联上的那行就是 null<br/> union 的作用是连接俩个/多个查询的结果<br/> 现有表如下</p> <pre>torder
id  product   price_o    price_c  num   stat
1   p1            3               3           5         1
1   p2            41             43         3         1
1   p3            23             26         1         2
1   p4            10             15         12       2
2   p5            20             16         1         2
2   p6            43             45         4         3
2   p7            60             65         1         2
3   p2            55             54         3         2</pre> <p>现要查寻出所有订单的总金额, 当 stat 为 1 的时候取 price_o 的值, 其他状态都取 price_c 的值.</p> <p>总价的计算方式是数量*价格, 但是这里的条件中要求不同的状态取不同的价格,就无法直接计算, 需要先计算出不同状态下不同的总金额, 在相加得出总金额</p> <p>使用 full join 方式</p> <pre>select * from (
    select  id, product, price_o, num from torder where stat=1
) as j1 full join (
    select id, product, price_c, num from torder where stat in (2,3)
) as j2 on j1.product=j2.product
</pre> <p>这样查询出来后的结果</p> <table border="1"> <tbody> <tr bgcolor="#CCCCFF"> <th>id</th> <th>product</th> <th>price_o</th> <th>num</th> <th>id</th> <th>product</th> <th>price_c</th> <th>num</th> </tr> <tr> <td>&lt;null&gt;</td> <td>&lt;null&gt;</td> <td>&lt;null&gt;</td> <td>&lt;null&gt;</td> <td>1</td> <td>p3</td> <td>26</td> <td>1</td> </tr> <tr> <td>&lt;null&gt;</td> <td>&lt;null&gt;</td> <td>&lt;null&gt;</td> <td>&lt;null&gt;</td> <td>1</td> <td>p4</td> <td>15</td> <td>12</td> </tr> <tr> <td>&lt;null&gt;</td> <td>&lt;null&gt;</td> <td>&lt;null&gt;</td> <td>&lt;null&gt;</td> <td>2</td> <td>p5</td> <td>16</td> <td>1</td> </tr> <tr> <td>&lt;null&gt;</td> <td>&lt;null&gt;</td> <td>&lt;null&gt;</td> <td>&lt;null&gt;</td> <td>2</td> <td>p6</td> <td>45</td> <td>4</td> </tr> <tr> <td>&lt;null&gt;</td> <td>&lt;null&gt;</td> <td>&lt;null&gt;</td> <td>&lt;null&gt;</td> <td>2</td> <td>p7</td> <td>65</td> <td>1</td> </tr> <tr> <td>1</td> <td>p2</td> <td>41</td> <td>3</td> <td>3</td> <td>p2</td> <td>54</td> <td>3</td> </tr> <tr> <td>1</td> <td>p1</td> <td>3</td> <td>5</td> <td>&lt;null&gt;</td> <td>&lt;null&gt;</td> <td>&lt;null&gt;</td> <td>&lt;null&gt;</td> </tr> </tbody> </table> <p>订单1和3中有相同的p2商品, 被关联到了一起, 而其他没有被关联上的都填null了, 到这一步就可以进行计算了</p> <pre>select
isnull(j1.product, j2.product) as product,
isnull(j1.price_o, 0)*isnull(j1.num, 0) +isnull(j2.price_c, 0)*isnull(j2.num, 0) as money
from (
    select  id, product, price_o, num from torder where stat=1
) as j1 full join (
    select id, product, price_c, num from torder where stat in (2,3)
) as j2 on j1.product=j2.product
order by isnull(j1.product, j2.product)</pre> <table border="1"> <tbody> <tr bgcolor="#CCCCFF"> <th>product</th> <th>money</th> </tr> <tr> <td>p1</td> <td>15</td> </tr> <tr> <td>p2</td> <td>285</td> </tr> <tr> <td>p3</td> <td>26</td> </tr> <tr> <td>p4</td> <td>180</td> </tr> <tr> <td>p5</td> <td>16</td> </tr> <tr> <td>p6</td> <td>180</td> </tr> <tr> <td>p7</td> <td>65</td> </tr> </tbody> </table> <p>这一步首先判断是否为空, 左右表中价格和数量是null的全部填0, 然后计算数量*价格就是该商品的金额, 然后加俩个金额相加就是总金额了, 之后在进行一次sum就是所有订单的金额.</p> <p> </p> <p>使用 union 方式</p> <p>相对来说 union 方式会简单很多, 并没有 full join 这么复杂</p> <pre>select product, sum(money) as money from (
    select product, num*price_o as money from torder where stat=1
    union
    select product, num*price_c as money from torder where stat in (2,3)
) as j
group by j.product
order by j.product</pre> <table border="1"> <tbody> <tr bgcolor="#CCCCFF"> <th>product</th> <th>money</th> </tr> <tr> <td>p1</td> <td>15</td> </tr> <tr> <td>p2</td> <td>285</td> </tr> <tr> <td>p3</td> <td>26</td> </tr> <tr> <td>p4</td> <td>180</td> </tr> <tr> <td>p5</td> <td>16</td> </tr> <tr> <td>p6</td> <td>180</td> </tr> <tr> <td>p7</td> <td>65</td> </tr> </tbody> </table> <p>这样就能够实现不同状态取不同的值合并起来了.<br/> 去除 product 字段 sum(money) 就是所有订单总金额.</p> <p> </p> <p>--</p> <p>相对来说 union 写起来较 full join 要方便, 从直觉上判断 union 的效率也比 full join 要高. full join 会产生很多的冗余数据, 需要进行判断, 而 union 则不会.</p> <p>俩着也都有着不友好的地方,</p> <p>full join 相对书写叫麻烦, 另外 full join 在连续使用多次的时候会导致数据错误</p> <pre>select * fom a
full join b on a.id=b.id
full join c on a.id=c.id</pre> <p>这个时候 如果 a 的 id 在 b 中被关联到了 在 c 中没有被关联到(具体情况已忘), 最后可能会产生重复数据, 同理用 b 去关联 c 也是如此, 多个 full join 应该利用子查询来进行</p> <pre>select * from (
select isnull(a.xx,b.xx).... from a
full join b on a.id=b.id
) as abj 
full join c on abj.id=c.id</pre> <p>这样才可以避免俩边数据不对等所造成的重复, 数据不统一的问题</p> <p>而 union 在连接的时候很方便, 但是要对后续的处理很麻烦, 必须要在外部嵌套一个 select 把 union 当作子查询, 外部的 select 来操作这个查询后的表.</p> <p> </p> <p>解决问题的方式并不止一种, 试情况而待.</p></section> <footer class="post-foot"> <ul class="post-tags"> <li><a href="/tag/full-join">full join</a></li> <li><a href="/tag/join">join</a></li> <li><a href="/tag/mssql">mssql</a></li> <li><a href="/tag/sql">sql</a></li> <li><a href="/tag/union">union</a></li> </ul> </footer> </article> <article class="post"> <header class="post-head"> <time datetime="2013-10-25T16:48:45.000Z">October 25, 2013</time> <h1><a href="/post/sql-in-or-and-union-efficiency/">sql 中 or 和 union 效率</a></h1> </header> <section class="post-main"><p> </p> <p>select * from tablename where time=’2013-1-1′ or time=’2013-1-15′;</p> <p>select * from tablename where time=’2013-1-1′<br/> union<br/> select * from tablename where time=’2013-1-15′;</p> <p>or 查询会将表里面的所有数据都检索一次然后再去进行匹配</p> <p>union 查询 多个查询语句查多少数据只检索多少条</p> <p> </p> <p>去查了查 发现了俩中结果 乱了 。。。</p> <p>http://www.open-open.com/lib/view/open1346289165426.html</p> <p> </p> <blockquote> <p>笔者发现如果or两边的查询列是一样的话,那么用union则反倒和用or的执行速度差很多,虽然这里union扫描的是索引,而or扫描的是全表。</p> <p>select gid,fariqi,neibuyonghu,reader,title from Tgongwen where fariqi=‘2004-9-16‘ or fariqi=‘2004-2-5‘</p> <p>用时：6423毫秒。扫描计数 2,逻辑读 14726 次,物理读 1 次,预读 7176 次。</p> <p>select gid,fariqi,neibuyonghu,reader,title from Tgongwen where fariqi=‘2004-9-16‘</p> <p>union</p> <p>select gid,fariqi,neibuyonghu,reader,title from Tgongwen where fariqi=‘2004-2-5‘</p> <p>用时：11640毫秒。扫描计数 8,逻辑读 14806 次,物理读 108 次,预读 1144 次</p> </blockquote> <p>http://blog.csdn.net/duanjianmin/article/details/6631339</p> <p> </p> <blockquote> <p align="left"> 当SQL语句有多个or语句时，可以考虑使用union或者union all代替来提高速度。使用or的SQL语句往往无法进行优化，导致速度变慢。但这不是固定的，有时候使用or速度会更快些。具体情况还要经过测试为准。如果加索引的话，也可能实现速度优化。</p> <p align="left"> 实验表格如下,实际数据有2,000,000条，从里面返回大约最多1000行左右的数据。</p> <table id="table1" border="1"> <tbody> <tr> <td align="center" bgcolor="#c0c0c0">X</td> <td align="center" bgcolor="#c0c0c0">Y</td> <td align="center" bgcolor="#c0c0c0">Inline</td> <td align="center" bgcolor="#c0c0c0">CDP</td> <td align="center" bgcolor="#c0c0c0">T</td> </tr> <tr> <td>12002400</td> <td>5801000</td> <td>300</td> <td>300</td> <td>3400</td> </tr> <tr> <td>12002408</td> <td>5801005</td> <td>300</td> <td>301</td> <td>3402</td> </tr> <tr> <td>12002416</td> <td>5801010</td> <td>300</td> <td>302</td> <td>3404</td> </tr> <tr> <td>12002424</td> <td>5801015</td> <td>300</td> <td>303</td> <td>3406</td> </tr> <tr> <td>...</td> <td>...</td> <td>...</td> <td>...</td> <td>...</td> </tr> </tbody> </table> <p>or语句(部分节选)</p> <p align="left">SELECT * FROM tablename where (cdp= 300 and inline=301) or (cdp= 301 and inline=301) or (cdp= 302 and inline=301) or (cdp= 303 and inline=301) or (cdp= 304 and inline=301) or (cdp= 305 and inline=301) or (cdp= 306 and inline=301) or (cdp= 307 and inline=301)</p> <p align="left">union all语句(部分节选)</p> <p align="left">SELECT * FROM tablename where (inline= 300 and cdp=300) union all SELECT * FROM tablename where (inline= 301 and cdp=300) union all SELECT * FROM tablename where (inline= 302 and cdp=300) union all SELECT * FROM tablename where (inline= 303 and cdp=300)</p> <p align="left">返回不规则的900条数据，前者用了60多秒，后者用了8秒左右。</p> </blockquote> <p>到底是哪个我也不知到了，，，，</p> <p>这事还是得自己测 。。。。。</p> <p>现在也没有数据。。。。。</p> <p>过段时间有大批量的数据 就来测试测试 暂时先用or来查询</p> <p> </p> <p> </p> <p>========================== 14-08-08 修改</p> <p>这么长时间了 也使用了好多了 现在来看 in 和 or 的效率比较从大数据方面来说 in 应该会比 or 效率更高</p> <p>in的逻辑是 目标数据中使用有和 in 里面有像匹配的</p> <p>in 的查询在拿到目标数据后, 遍历判断是否有in里面相同的值</p> <p>而对用or来说, 有多少or就遍历几次目标数据,判断是否有相同的值</p> <p> </p> <p>============================14-09-27</p> <p>楼上的二货...</p> <p>标题明明写着 or union 的效率</p> <p>回什么 or 和 in</p> <p>..... 脑抽</p></section> <footer class="post-foot"> <ul class="post-tags"> <li><a href="/tag/mysql">mysql</a></li> <li><a href="/tag/or">or</a></li> <li><a href="/tag/sql">sql</a></li> <li><a href="/tag/union">union</a></li> </ul> </footer> </article> <menu class="page"> </menu> </main> <footer class="foot"> <div>&copy;2017 iaceob</div> </footer> </body> </html>